#!/bin/sh

prompt_command_main() {
    local cmd_exit=$?
    [ -n "$1" ] && cmd_exit=$1
    local git_ref="$(__git_ps1 '%s')"
    local git_dirty=""
    [[ $(git status 2> /dev/null | tail -n1) != "nothing to commit (working directory clean)" ]] && git_dirty="*"
    local git_sha1="$(git rev-parse --short HEAD 2>/dev/null)"

    local fg_black=$(tput setaf 0)
    local fg_red=$(tput setaf 1)
    local fg_green=$(tput setaf 2)
    local fg_yellow=$(tput setaf 3)
    local fg_blue=$(tput setaf 4)
    local fg_magenta=$(tput setaf 5)
    local fg_cyan=$(tput setaf 6)
    local fg_white=$(tput setaf 7)
    local reset=$(tput sgr0)

    if [ $cmd_exit -eq 0 ]; then
        cmd_exit=''
    else
        cmd_exit="# => \[${fg_red}\]${cmd_exit}\[${reset}\]\n\n"
    fi

    local git_status=''
    if [ -n "${git_ref}" ]; then
        git_status="on \[${fg_yellow}\]${git_ref}@${git_sha1}${git_dirty}\[${reset}\] "
    fi

    local user="\[${fg_cyan}\]\u\[${reset}\] "
    local host="at \[${fg_green}\]\h\[${reset}\] "
    local dir="in \[${fg_magenta}\]\w\[${reset}\] "

    export PROMPT_COMMAND=prompt_command_newline
    export PS1="${cmd_exit}${user}${host}${dir}${git_status}\n~> "
}

prompt_command_newline() {
    local cmd_exit=$?
    echo ''
    prompt_command_main $cmd_exit
}

PROMPT_COMMAND=prompt_command_main
